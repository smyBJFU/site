# 线程池

#### **一、为什么需要线程池？**

1. **降低资源消耗**：线程的创建和销毁是昂贵的操作，会消耗 CPU 时间和内存。线程池通过**复用**已存在的线程，极大地降低了这种开销。
2. **提高响应速度**：当任务到达时，无需等待线程创建即可立即执行，从而提高了系统的响应速度。
3. **提高线程的可管理性**：线程是稀缺资源。线程池可以统一进行分配、调优和监控，防止无限制地创建线程，从而避免因资源耗尽而导致的系统崩溃（OOM）。
4. **提供更强大的功能**：线程池提供了定时执行、定期执行、单线程、并发数控制等高级功能。

#### **二、线程池的核心实现 (`ThreadPoolExecutor`)**

在 Java 中，`java.util.concurrent.ThreadPoolExecutor` 是线程池最核心的实现类。

##### **核心参数详解**

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

- `corePoolSize` (核心线程数)
  - 线程池中保持存活的线程数，即使它们是空闲的。
  - **一个关键点**：默认情况下，核心线程不会超时销毁。但可以通过调用 `allowCoreThreadTimeOut(true)` 方法来让核心线程也应用 `keepAliveTime` 的超时策略。
- `maximumPoolSize` (最大线程数)
  - 线程池能够容纳同时执行的最大线程数。此值必须大于等于 `corePoolSize`。
  - 当 `workQueue` 满了之后，线程池才会尝试创建新线程，直到总线程数达到 `maximumPoolSize`。
- `keepAliveTime` & `unit` (空闲线程存活时间)
  - 当线程池中的线程数量大于 `corePoolSize` 时，如果一个线程的空闲时间超过 `keepAliveTime`，那么这个线程将被终止，以释放资源。
- `workQueue` (任务队列)
  - 用于存储等待执行的任务的阻塞队列。队列的选择对线程池的行为有重大影响：
  - `ArrayBlockingQueue`：基于数组的有界队列，按 FIFO（先进先出）排序。必须指定容量。
  - `LinkedBlockingQueue`：基于链表的队列，按 FIFO 排序。吞吐量通常高于 `ArrayBlockingQueue`。如果不指定容量，默认为 `Integer.MAX_VALUE`，可能导致任务无限堆积，造成内存溢出。**这是最常用的队列之一**。
  - `SynchronousQueue`：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。通常配合 `maximumPoolSize` 为无限大（如 `Integer.MAX_VALUE`）使用，适合处理大量、处理时间短的请求。
  - `PriorityBlockingQueue`：具有优先级的无界队列。
- `threadFactory` (线程工厂)
  - 用于创建新线程。通过自定义 `ThreadFactory`，可以给线程设置一个有意义的名字、设置守护线程状态、设置线程优先级等。这对于调试和问题排查（如通过 `jstack` 查看线程堆栈）非常重要。
  - 推荐使用 Guava 或 Apache Commons Lang 提供的 `ThreadFactoryBuilder` 来方便地创建。
- `handler` (拒绝策略)
  - 当线程池和任务队列都满了之后，新任务的处理策略。JDK 提供了四种默认策略：
  - `AbortPolicy` (默认)：直接抛出 `RejectedExecutionException` 异常，阻止系统正常工作。
  - `CallerRunsPolicy`：**“调用者运行”** 策略。该策略既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者（提交任务的线程），由该线程自己来执行。这是一种有效的降级和限流策略。
  - `DiscardPolicy`：直接丢弃任务，不做任何处理。
  - `DiscardOldestPolicy`：丢弃队列中最老的任务（即队首的任务），然后尝试再次提交当前任务。

##### **线程池工作机制 **

当一个新任务通过 `execute()` 方法提交时，`ThreadPoolExecutor` 的处理流程如下：

1. **检查核心线程**：判断当前运行的线程数是否小于 `corePoolSize`。
   - **是**：创建一个新的**核心线程**来执行该任务，即使有其他空闲的核心线程。
   - **否**：进入下一步。
2. **尝试入队**：判断任务队列 `workQueue` 是否已满。
   - **否**：将任务放入队列中等待执行。
   - **是**：进入下一步。
3. **尝试创建非核心线程**：判断当前运行的线程数是否小于 `maximumPoolSize`。
   - **是**：创建一个新的**非核心线程**来执行该任务。
   - **否**：说明线程池已达到极限，进入下一步。
4. **执行拒绝策略**：执行 `RejectedExecutionHandler` 所定义的拒绝策略。



**任务提交：`execute()` vs `submit()`**

- `execute(Runnable command)`
  - 无返回值。
  - 如果任务在执行过程中抛出异常，异常会直接抛给线程的 `UncaughtExceptionHandler`，通常会导致该线程终止。
- `submit(Runnable task)` 或 `submit(Callable<T> task)`
  - 返回一个 `Future` 对象。
  - `Future` 对象可以用来检查任务是否完成、取消任务、以及获取任务的执行结果。
  - 如果任务抛出异常，异常会被包装在 `Future` 对象中。只有当你调用 `future.get()` 方法时，异常才会被重新抛出（包装在 `ExecutionException` 中）。**这种方式使得异常处理更加灵活**。



#### **三、线程池参数如何设置**

这是实践中的核心问题，没有银弹，需要根据任务的类型来分析：

- **CPU 密集型任务 **
  - **特点**：大量计算，消耗 CPU 资源，例如视频编码、科学计算。
  - **策略**：线程数不宜过多，通常设置为 CPU 核心数 `N` 或 `N+1`。过多的线程会导致频繁的上下文切换，反而降低性能。
  - **配置**：`corePoolSize = N`, `maximumPoolSize = N+1`。`workQueue` 容量不宜过大。
  - **获取 CPU 核心数**: `int cores = Runtime.getRuntime().availableProcessors();`
- **I/O 密集型任务**
  - **特点**：线程大部分时间在等待 I/O 操作完成，例如数据库查询、网络请求。CPU 利用率不高。
  - **策略**：可以配置更多的线程，以在等待 I/O 的时间内，让 CPU 去处理其他任务，从而提高吞吐量。
  - **经典公式**：`线程数 = N * (1 + W/C)`，其中 `N` 是 CPU 核心数，`W` 是等待时间 (Wait time)，`C` 是计算时间 (Compute time)。
  - **简化配置**：一个常用的经验法则是 `2N`。例如，如果一个任务有 50% 的时间在等待，那么可以设置 `N * (1 + 50%/50%) = 2N`。
  - **配置**：`corePoolSize` 和 `maximumPoolSize` 可以设置得大一些，例如 `2N` 或更多，具体数值需要通过**压力测试**来确定。



#### **四、线程池的五种状态 (States)**

`ThreadPoolExecutor` 内部通过一个原子变量 `ctl` 来同时表示**运行状态 (runState)** 和**工作线程数 (workerCount)**。理解其状态对于深入排查问题至关重要。

1. `RUNNING`：能接受新任务，也能处理队列中的任务。
2. `SHUTDOWN`：**不接受新任务**，但会处理完队列中已存在的任务。调用 `shutdown()` 后进入此状态。
3. `STOP`：**不接受新任务，也不处理队列任务**，并且会**中断**正在执行的任务。调用 `shutdownNow()` 后进入此状态。
4. `TIDYING`：所有任务都已终止，工作线程数为 0。此状态下会执行 `terminated()` 钩子方法。
5. `TERMINATED`：`terminated()` 方法执行完毕后的最终状态。



#### **五、线程池的监控 (Monitoring)**

当系统出现性能问题时，监控线程池的运行状况是排查问题的关键手段。`ThreadPoolExecutor` 提供了丰富的监控方法：

- `getTaskCount()`: 线程池已执行和未执行的任务总数。
- `getCompletedTaskCount()`: 已完成的任务数。
- `getPoolSize()`: 线程池当前的线程数。
- `getActiveCount()`: 当前正在执行任务的线程数。
- `getLargestPoolSize()`: 线程池曾经达到过的最大线程数，用于评估 `maximumPoolSize` 是否合理。
- `getQueue().size()`: 任务队列中等待的任务数。

**实践建议**： 可以通过集成 Micrometer、Prometheus 等监控框架，定期采集这些指标，并配置告警。例如，当 `getQueue().size()` 持续过高时，说明任务处理不过来，可能需要扩容或优化。



#### **六、如何优雅地关闭线程池 (Graceful Shutdown)**

直接关闭应用程序（如 `kill -9`）或不正确地关闭线程池，可能导致任务丢失或数据不一致。优雅关闭是保证系统稳定性的关键。

**标准关闭流程：**

1. **`shutdown()`**:
   - 启动平滑关闭流程。线程池进入 `SHUTDOWN` 状态。
   - 它会等待所有已提交的任务（包括队列里的）执行完成，但不再接受新任务。
2. **`awaitTermination(long timeout, TimeUnit unit)`**:
   - 这是一个**阻塞**方法。它会等待线程池达到 `TERMINATED` 状态，或者等待超过指定的 `timeout` 时间。
   - 返回值是 `boolean`，如果在超时前线程池成功终止，则返回 `true`。
3. **`shutdownNow()`**:
   - 尝试立即停止所有正在执行的任务，并返回队列中未执行的任务列表。线程池进入 `STOP` 状态。
   - 它通过调用工作线程的 `thread.interrupt()` 方法来尝试中断任务。如果你的任务逻辑没有正确响应中断，它可能不会立即停止。

不正确地关闭线程池可能导致任务丢失或数据不一致。**两阶段关闭 (Two-Phase Shutdown)** 是保证系统稳定性的最佳实践。

```java
ExecutorService executor = ...;

// 1. 发起平滑关闭
executor.shutdown(); // 状态变为 SHUTDOWN，不再接受新任务
try {
    // 2. 设置一个合理的超时时间，等待现有任务执行完成
    if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
        // 3. 如果超时，则强制关闭
        System.err.println("线程池超时未关闭，强制关闭...");
        List<Runnable> droppedTasks = executor.shutdownNow(); // 状态变为 STOP，中断正在执行的线程
        System.err.println("未执行的任务数：" + droppedTasks.size());

        // 4. (可选) 再次等待强制关闭操作完成
        if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
            System.err.println("线程池未能终止");
        }
    }
} catch (InterruptedException ie) {
    // 5. 如果当前线程在等待时被中断，也应立即进行强制关闭
    executor.shutdownNow();
    // 保持当前线程的中断状态
    Thread.currentThread().interrupt();
}
```







#### **七、使用 `Executors` 创建线程池**

`java.util.concurrent.Executors` 是一个便捷的工具类，它提供了一系列静态工厂方法来简化线程池的创建。

---

**1. `Executors.newFixedThreadPool(int nThreads)` - 固定大小线程池**

创建一个包含固定数量线程的线程池。

* **工作方式**:
    * 核心线程数 (`corePoolSize`) 和最大线程数 (`maximumPoolSize`) 都被设置为 `nThreads`。
    * 当所有线程都在忙碌时，新任务会进入一个任务队列中等待。
    * 使用的任务队列是 `LinkedBlockingQueue`。

* **潜在风险：内存溢出 (OOM)**
    * `newFixedThreadPool` 使用的 `LinkedBlockingQueue` 是一个**无界队列**（其默认容量为 `Integer.MAX_VALUE`）。
    * 如果任务提交的速度持续快于线程处理的速度，队列中的任务会无限堆积，最终耗尽服务器内存，导致 `OutOfMemoryError`。

---

**2. `Executors.newSingleThreadExecutor()` - 单线程线程池**

创建一个只有一个工作线程的线程池。

* **工作方式**:
    * 功能上等同于 `newFixedThreadPool(1)`。
    * 确保所有提交的任务都按照先进先出 (FIFO) 的顺序**串行执行**。
    * 同样，它也使用无界的 `LinkedBlockingQueue`作为任务队列。

* **潜在风险：内存溢出 (OOM)**
    * 风险与 `newFixedThreadPool` 完全相同。由于队列是无界的，任务的持续积压同样会导致内存耗尽。

---

**3. `Executors.newCachedThreadPool()` - 缓存线程池**

创建一个可根据需要动态伸缩的线程池。

* **工作方式**:
    * 核心线程数 (`corePoolSize`) 为 `0`。
    * 最大线程数 (`maximumPoolSize`) 被设置为 `Integer.MAX_VALUE`，这几乎等同于**无限制**。
    * 任务队列采用 `SynchronousQueue`，它不存储元素，而是直接将任务交给一个可用线程。如果没有可用线程，则会立即创建一个新线程。
    * 线程在空闲超过 60 秒后会被自动回收。

* **潜在风险：资源耗尽**
    * 由于最大线程数近乎无限，当系统面临瞬时高并发请求时，线程池可能会毫无节制地创建大量新线程。
    * 创建过多线程会消耗大量内存和 CPU 资源，可能导致系统响应缓慢，甚至因资源耗尽而崩溃 (`OutOfMemoryError`)。

---

**最佳实践：为什么不推荐使用 `Executors`？**

> **阿里巴巴《Java 开发手册》强制规定**：
> 不允许使用 `Executors` 创建线程池，而是通过 `ThreadPoolExecutor` 的构造函数手动创建。

**原因**:
手动创建能让开发者更明确线程池的运行规则（如核心线程数、最大线程数、队列类型和容量、拒绝策略等），从而有效规避因队列无界或线程数无限而导致的资源耗尽风险。



#### 八、常见问题

1. **`ThreadLocal` 的内存泄漏问题**：

   - `ThreadLocal` 为每个线程提供了独立的变量副本。

   - 在线程池中，线程是复用的。如果一个任务在 `ThreadLocal` 中存了数据，但任务结束后没有清理（调用 `remove()` 方法），那么这些数据会一直保留在该线程上。当这个线程被下一个任务复用时，可能会读取到上一个任务的脏数据。更严重的是，如果 `ThreadLocal` 存的是大对象，将导致**内存泄漏**。

   - **解决方案**：在 `finally` 块中确保调用 `threadLocal.remove()`。



2. **异常处理的陷阱**：

   - 如果通过 `execute()` 提交的任务抛出了未检查异常，而你没有设置 `UncaughtExceptionHandler`，那么异常信息会被打印到标准错误流，并且**该工作线程会异常终止**。线程池会创建一个新线程来替代它，但这会带来额外的开销和不确定性。

   - **解决方案**：
     - 在 `Runnable` 的 `run()` 方法内部使用 `try-catch` 捕获所有异常。
     - 使用 `submit()` 并检查 `Future.get()` 的结果（它会抛出 `ExecutionException`）。




3. **线程池隔离**

   在复杂的微服务应用中，不同的业务或调用方的重要性是不同的。如果所有业务都共用一个线程池，一个次要业务的流量激增或代码缺陷（如慢查询）可能会占满所有线程，导致核心业务无法处理，引发**雪崩效应**。

   **解决方案**： 为不同业务或不同重要性等级的请求创建不同的线程池。例如：

   - order-thread-pool`: 处理订单相关的核心业务。

   - `log-thread-pool`: 处理日志记录等非核心业务。

   - `third-party-api-pool`: 用于调用外部接口，这类 I/O 任务很容易变慢，最需要隔离。


​	这种模式以增加少量资源消耗为代价，换取了系统的**高可用性和稳定性**。
